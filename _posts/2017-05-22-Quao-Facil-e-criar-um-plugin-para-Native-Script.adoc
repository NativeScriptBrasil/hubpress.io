= Qu√£o facil √© criar um plugin para NativeScript

:hp-tags: NativeScript, plugin
:hp-alt-title: Qu√£o Facil √© criar um plugin para NativeScript

√â not√≥rio a crescente quantidade de plugins dispon√≠veis para NativeScript desenvolvidos pela comunidade, e o motivo disso n√£o √© apenas a boa vontade e senso de contribui√ß√£o por parte de quem desenvolve, e sim, inclusive, a **facilidade que √© desenvolver um plugin para NativeScript**, principalmente depois da vers√£o 3.0.

Neste artigo, irei demonstrar como desenvolvi o **https://github.com/dzfweb/nativescript-emoji[NativeScript Emoji]**, meu primeiro  UI Plugin para NativeScript. Ao termino da leitura deste artigo, espero despertar em voc√™ o interesse em desenvolver tamb√©m um plugin e contribuir para a comunidade de desenvolvedores NativeScript, quem ganha com isso somos n√≥s mesmos.

== Por onde come√ßar?
N√£o vou entrar em detalhes sobre toda a estrutura necessaria para desenvolver um plugin para NativeScript pois isso n√£o vai ser necess√°rio para este artigo. Vou demonstrar o basico que voc√™ precisa saber para come√ßar, mas caso prefira, a documenta√ß√£o completa voc√™ pode acessar https://docs.nativescript.org/plugins/plugins[clicando aqui].

A maneira mais facil de come√ßar um plugin para NativeScript, √© utilizando o  **https://github.com/NathanWalker/nativescript-plugin-seed[NativeScript Plugin Seed]**, criado por NathanWalker. Esta biblioteca far√° todo o trabalho √°rduo de cria√ß√£o da estrutura de um plugin NativeScript, e isso √© realmente incr√≠vel. Veja como √© facil:

. git clone https://github.com/NathanWalker/nativescript-plugin-seed.git myplugin
. cd myplugin
. npm run postclone
. npm run setup

Pronto, com apenas estas etapas voc√™ ter√° criado toda estrutura necess√°ria para desenvolver, testar e publicar seu plugin, mas antes de por a m√£o na massa, vamos fazer uma breve introdu√ß√£o sobre o plugin que vamos desenvolver juntos neste artigo.

== O plugin NativeScript Emoji
O objetivo deste plugin √© entregar um elemento para a interface para exibir Emojis de forma amigavel. A minha ideia inicial era ter um elemento TextView onde ao definir o valor unicode ou hexadecimal do emoji na propriedade correspondente:

`<Emoji:Emoji icon="128514">` *exibir* :üòÇ 
 
O plugin faria a convers√£o para Emoji, e aqui eu deixo um destaque novamente para a comunidade NativeScript no Slack (se voc√™ ainda n√£o participa, fa√ßa sua inscri√ß√£o agora http://developer.telerik.com/wp-login.php?action=slack-invitation[clicando aqui]), que me fizeram uma excelente sugest√£o de substituir a propriedade unicode por um valor amigavel e mais facil de lembrar, ficando ent√£o:

`<Emoji:Emoji name="joy">` *exibir* :üòÇ 

== Implementa√ß√£o para Android e iOS
Agora que j√° temos a defini√ß√£o do plugin e a estrutura criada, √© hora de por a m√£o na massa. A primeira coisa que precisamos fazer √© definir a implementa√ß√£o comum entre as plataformas, sabemos que iremos ter uma propriedade **name** que servir√° tanto para Android como para iOS, esta defini√ß√£o √© feita no arquivo common que foi gerado na primeira etapa deste artigo.

**emoji.common.ts**
```
import { View, Property } from "ui/core/view";

export class EmojiCommon extends View {
  name: string;
}

export const nameProperty = new Property<EmojiCommon, string>(
  {
    name: "name",
    defaultValue: ""
  });
nameProperty.register(EmojiCommon);
```
Como se trata de um plugin para interface, precisamos extender a classe **View**. Os atributos do elemento que iremos criar, definimos criando um novo objeto do tipo **Property**, a propriedade **name** definimos o nome do atributo e o valor padr√£o, como o pr√≥prio nome sugere, definimos na propriedade **defaultValue**. Se o valor deste atributo fosse diferente do tipo **string**, que n√£o √© o nosso caso, seria necess√°rio definir o valor para a propriedade **valueConverter**.

A codifica√ß√£o dos emojis s√£o distintas para cada plataforma, por tanto precisamos ter uma base de dados para armazenar esses valores para consultarmos durante a execu√ß√£o do plugin.

**emoji.database.ts**
```
export class EmojiDatabase {
    public static list(): Array<any> {
      return [
    {
        "name": "FACE WITH TEARS OF JOY",
        "unicode": "üòÇ",
        "hexcode": "1F602",
        "codepoint": [
            128514
        ],
        "shortname": "joy"
    }];
}
```

=== Implementa√ß√£o para Android
Agora que ja temos os atributos do elemento que iremos criar, precisamos implementar o codigo respons√°vel por gerar o elemento correspondente a cada plataforma. O NativeScript interpretar√° em tempo de execu√ß√£o o codigo espec√≠fico para Android atrav√©z do seguinte arquivo.

**emoji.android.ts**
```
import { nameProperty, EmojiCommon } from "./emoji.common";
import { EmojiDatabase } from "./emoji.database";
import * as utils from "tns-core-modules/utils/utils";
declare var java: any;

global.moduleMerge(EmojiCommon, exports);

export class Emoji extends EmojiCommon {
  [nameProperty.getDefault](): string {
    return '';
  }
  [nameProperty.setNative](value: string) {
    let emoji = EmojiDatabase.list().find((el) => el.shortname === value).codepoint[0];
    this.nativeView.setText(new java.lang.String(java.lang.Character.toChars(emoji)));
  }

  private _android: android.widget.TextView;

  get android() {
    return this.nativeView;
  }

  public createNativeView() {
    this._android = new android.widget.TextView(utils.ad.getApplicationContext());
    return this._android;
  }
}
```

O primeiro passo √© extender a classe common criada anteriormente. Por se tratar de um plugin para interface, √© necess√°rio implementarmos o m√©todo **createNativeView**, que far√° com que o o NativeScript entenda que algum elemento tem de ser criado na View. No nosso caso criaremos um https://developer.android.com/reference/android/widget/TextView.html[TextView]. 

E novamente aqui temos outra grande ajuda do framework, a equipe do NativeScript mapeou todas as propriedades e m√©todos nativos de cada plataforma e gerou as defini√ß√µes em TypeScript, o que nos da a possibilidade de navegar por todas estas defini√ß√µes nativas diretamente no editor.

Temos que definir tamb√©m o que o plugin far√° quando receber o atributo **name**, isso √© definido implementando o m√©todo *setNative*, que no nosso caso ir√° consultar o nome do emoji na base de dados, e com base no codigo correspondente, definira o valor para o TextView criado anteriormente. O metodo *getDefault* √© para casos em que nenhum valor seja definido.

=== Implementa√ß√£o para iOS
Podemos copiar a mesma implementa√ß√£o feita para o Android, e alterar somente as partes onde √© criado e definido o valor para o elemento nativo, que no caso do iOS ser√°  o https://developer.apple.com/reference/uikit/uilabel[UILabel] ficando da seguinte maneira.

**emoji.ios.ts**
```
import { nameProperty, EmojiCommon } from "./emoji.common";
import { EmojiDatabase } from "./emoji.database";

global.moduleMerge(EmojiCommon, exports);

export class Emoji extends EmojiCommon {
  [nameProperty.getDefault](): number {
    return 0;
  }
  [nameProperty.setNative](value: string) {
    let emoji = EmojiDatabase.list().find((el) => el.shortname === value).unicode;
    let nsString = NSString.stringWithString(emoji);
    this.nativeView.text = nsString;
  }

  private _ios: UILabel;

  get ios() {
    return this.nativeView;
  }

  public createNativeView() {
    this._ios = UILabel.alloc().init();
    return this._ios;
  }
}
```

Novamente aqui ser√° possivel acessar a defini√ß√£o dos metodos nativos para iOS, no metodo *createNativeView* √© criado um UILabel e no m√©todo *setNative* √© definido o valor para o elemento criado.

== Testando o plugin 
Sim, terminamos a implementa√ß√£o do plugin e o que resta agora √© apenas testarmos. Rapido n√£o? Para testarmos precisamos adicionar o plugin ao projeto *demo* criado nas etapas iniciais deste artigo. Para isso, √© necess√°rio executar o comando:

```
npm run preparedemo
```

Adicionar a referencia do elemento no elemento *Page* do arquivo *main-page.xml*

```
xmlns:Emoji="nativescript-emoji"
``` 

e ent√£o adicionar o elemento no dentro do *StackLayout*

```
<Emoji:Emoji name="joy" />
```

Ficando da seguinte maneira.

*main-page.xml*
```
<Page xmlns="http://schemas.nativescript.org/tns.xsd" xmlns:Emoji="nativescript-emoji" navigatingTo="navigatingTo" class="page">
  
    <Page.actionBar>
        <ActionBar title="NativeScript Emoji" icon="" class="action-bar">
        </ActionBar>
    </Page.actionBar>
    <StackLayout orientation="horizontal">
        <Label text="I'm happy "> </Label>
        <Emoji:Emoji name="joy" />
        <Emoji:Emoji name="joy" />
        <Emoji:Emoji name="joy" />
    </StackLayout>
</Page>
```

Agora resta executar o projeto de demonstra√ß√£o nos emuladores de cada plataforma executando os seguintes comandos.

```
nmm run demo.ios
npm run demo.android
```

image:https://raw.githubusercontent.com/dzfweb/nativescript-emoji/master/emojiprintscreen.png[]

== Conclus√£o
Podemos ver como √© facil e rapido desenvolver um plugin para NativeScript, destaco alguns pontos como a comunidade de desenvolvedores NativeScript que s√£o bem participativos, a equipe da Telerik que a procura entregar a cada vers√£o ferramentas que vis√£o tornar nosso trabalho como desenvolvedor muito mais produtivo e lan√ßo o convite para voc√™ desenvolvedor que est√° lendo este artigo. Voc√™ desenvolveu algo customizado em algum projeto? Tem alguma ideia sobre alguma ferramenta que possa ser util? Contribua conosco tamb√©m.


